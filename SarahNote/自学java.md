[TOC]



# 方法

也叫函数

```java
public static void main(String[] args){
    //public static 修饰符 void 返回值类型 main方法名
    System.out.printIn("HelloWorld");
    return;

}
```

方法与方法是平级关系， 不能嵌套

## 方法的调用

通过方法名调用

将实参传给实参



## 方法的重载

同一类中方法名相同但是参数列表不同

why 功能相同方法不同



# 封装

类

对象

### 变量

#### 局部位置 - 方法参数列表/方法内

#### 成员位置 - 类中， 方法外

#### 区别 

- 位置不同
- 成员变量有初始化值， 局部变量无
- 成员变量在类中使用， 局部变量在方法中使用
- 成员变量存在堆内存，局部变量在栈内存
- 成员变量随着对象的创建存在，局部变量随着方法的调用存在

注意： 重名采用就近原则



### private

只能在本类中进行访问

private 一般用来修饰成员变量

public一般用来修饰成员方法



### this

本类对象

每个普通方法都有一个this 谁调用该方法 this就指向谁

重名 用来代表成员变量



### 构造方法

初始化对象的

方法名与类名相同

```java
public Student(){
    
}
```

没有返回值和返回值类型（但是里面可以写return）

构造方法可以重载





# 继承

```java
class 父类{
    //...
}
class 子类 extends 父类 {
    //...
}
```

子类 = 派生类

父类 = 基类 = 超类

子类拥有了父类的非私有成员



变量 就近  局部位置-》 本类成员-》父类成员

都有的时候想使用本类成员 this.name 想使用父类成员 super.name

子类可以通过重写父类方法更改

# 多态

### 抽象类

用abstract修饰 只有方法声明 没有方法体的方法 

当要定义一个方法，却不明确方法的具体实现时，可以将方法定义为abstract 具体实现延迟到子类

- 修饰符 abstract
- 抽象类不能被实例化（不能new）
- 子类的两个选择
  - 重写父类的所有抽象方法
  - 定义为抽象类

成员

- 成员变量 - 普通/成员常量（final）
- 成员方法 普通/抽象
- 构造方法 - 有且可以重载

抽象类中的成员比普通类多一种： 抽象方法 其他跟普通类一样

### static

 静态变量能被该类下所有的对象共享

方法： 没有对象this 所以不能访问非静态成员

当你想用类名.方法 而不是对象.方法的时候可以用静态方法（static可以直接用， 不用new）



## 接口

interface 接口名{}

class 类名 implements 接口名